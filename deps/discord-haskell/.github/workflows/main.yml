name: CI

# when the workflow will run
on:
  push:
    branches: [ master ]
  pull_request:

  # Allows manually starting this workflow from the Actions tab
  workflow_dispatch:

jobs:
  # To dynamically create a build matrix, we generate a JSON output from one job
  # and use fromJson in the next job to construct the matrix.
  # This dynamic approach means we don't have to update the CI file when we
  # change supported GHC versions.
  generate-matrix:
    name: Generate GHC build matrix
    runs-on: ubuntu-latest
    outputs:
      ghc-matrix: ${{ steps.set-ghc-matrix.outputs.versions }}
    steps:
      - uses: actions/checkout@v2

      - name: Parse the cabal tested-with stanza
        id: parse
        run: |
          echo "::set-output name=tested-with-versions::$(runghc .github/workflows/parseVersions.hs)"

      - name: Set the GHC matrix for the next job
        id: set-ghc-matrix
        # We use single quotes here, since the output from the previous step
        # will not have escaped double quotes, and it's just easier to use single
        # quotes on the outside than try to escape the inner double quotes.
        run: echo '::set-output name=versions::{"ghc-version":${{ steps.parse.outputs.tested-with-versions }}}'

  build:
    name: Build Check
    needs: generate-matrix
    runs-on: ubuntu-latest
    strategy:
      # Whether to stop other jobs in the matrix if one fails. This is undesirable
      # since we want to check e.g. it compiles on 8.10.7 regardless of the status
      # of 9.X.
      fail-fast: false
      # Feed the json from the previous job.
      matrix: ${{ fromJson(needs.generate-matrix.outputs.ghc-matrix) }}
    steps:
      - uses: actions/checkout@v2

      - uses: haskell/actions/setup@v2
        id: setup-haskell
        with:
          # We install a global GHC and use Stack with --system-ghc
          ghc-version: ${{ matrix.ghc-version }}
          enable-stack: true

      # First run cabal, since it is generally quicker
      - name: "Cabal: Update cabal package database, generate build plan"
        run: |
          cabal update
          cabal build --dry-run

      - name: "Cabal: Cache Dependencies"
        id: cache
        uses: actions/cache@v2
        with:
          # Include the build plan file generated by cabal configure, but allow
          # restoring without its hash as long as the GHC version is the same.
          key: cabal-${{ runner.os }}-${{ matrix.ghc-version }}-${{ hashFiles('**/plan.json') }}
          restore-keys: |
            cabal-${{ runner.os }}-${{ matrix.ghc-version }}
          path: |
            ${{ steps.setup-haskell.outputs.cabal-store }}
            dist-newstyle

      - name: "Cabal: Build"
        run: cabal build

      # Now run stack
      - name: "Stack: Cache ~/.stack"
        id: cache-stack
        uses: actions/cache@v2
        with:
          path: ~/.stack
          key: stack-${{ runner.os }}-${{ matrix.ghc-version }}-${{ hashFiles('stack.yaml') }}
          restore-keys: |
            stack-${{ runner.os }}-${{ matrix.ghc-version }}

      - name: "Stack: Build"
        run: stack build --system-ghc
