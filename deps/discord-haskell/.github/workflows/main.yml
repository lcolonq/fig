name: CI

# when the workflow will run
on:
  push:
    branches: [ master ]
  pull_request:

  # Allows manually starting this workflow from the Actions tab
  workflow_dispatch:

jobs:
  # To dynamically create a build matrix, we generate a JSON output from one job
  # and use fromJson in the next job to construct the matrix.
  # This dynamic approach means we don't have to update the CI file when we
  # change supported GHC versions.
  #
  # Only the Cabal build job will use the generated matrix, since Stack has a
  # pinned GHC version in the stack.yaml file.
  generate-matrix:
    name: Generate GHC build matrix for Cabal
    runs-on: ubuntu-latest
    outputs:
      ghc-matrix: ${{ steps.set-ghc-matrix.outputs.versions }}
    steps:
      - uses: actions/checkout@v2

      - name: Parse the cabal tested-with stanza
        id: parse
        run: |
          echo "tested-with-versions=$(runghc .github/workflows/parseVersions.hs)" >> $GITHUB_OUTPUT

      - name: Set the GHC matrix for the next job
        id: set-ghc-matrix
        # We use single quotes here, since the output from the previous step
        # will not have escaped double quotes, and it's just easier to use single
        # quotes on the outside than try to escape the inner double quotes.
        run: echo 'versions={"ghc-version":${{ steps.parse.outputs.tested-with-versions }}}' >> $GITHUB_OUTPUT

  build-cabal:
    name: Cabal Build Check
    needs: generate-matrix
    runs-on: ubuntu-latest
    strategy:
      # Whether to stop other jobs in the matrix if one fails. This is undesirable
      # since we want to check e.g. it compiles on 8.10.7 regardless of the status
      # of 9.X.
      fail-fast: false
      # Feed the json from the previous job.
      matrix: ${{ fromJson(needs.generate-matrix.outputs.ghc-matrix) }}
    steps:
      - uses: actions/checkout@v2

      # Although the GitHub Action Runner comes with pre-installed Cabal and GHC,
      # we'll only use Cabal out of the box since that is independent of
      # the GHC version. For GHC, we'll use the Haskell setup action to install
      # the correct version needed for the build.
      - uses: haskell/actions/setup@v2
        id: setup-haskell
        with:
          # We install a global GHC
          ghc-version: ${{ matrix.ghc-version }}

      - name: "Cabal: Update cabal package database, generate build plan"
        run: |
          cabal update
          cabal build --dry-run

      - name: "Cabal: Cache Dependencies"
        id: cache
        uses: actions/cache@v2
        with:
          # Include the build plan file generated by cabal configure, but allow
          # restoring without its hash as long as the GHC version is the same.
          key: cabal-${{ runner.os }}-${{ matrix.ghc-version }}-${{ hashFiles('**/plan.json') }}
          restore-keys: |
            cabal-${{ runner.os }}-${{ matrix.ghc-version }}
          path: |
            ${{ steps.setup-haskell.outputs.cabal-store }}
            dist-newstyle

      - name: "Cabal: Build"
        run: cabal build

  build-stack:
    name: Stack Build Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      # Since the GitHub Action Runner comes with a pre-installed Stack, we'll
      # use that instead of installing our own through the Haskell setup action,
      # since all we need to test the stack build is Stack itself.

      - name: "Stack: Cache ~/.stack"
        id: cache-stack
        uses: actions/cache@v2
        with:
          path: ~/.stack
          key: stack-${{ runner.os }}-${{ hashFiles('stack.yaml') }}
          restore-keys: |
            stack-${{ runner.os }}

      - name: "Print GHC version resolved from stack.yaml"
        run: |
          stack ghc -- --version
          stack path --compiler-exe

      - name: "Stack: Build"
        run: stack build
